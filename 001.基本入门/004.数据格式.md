# 数据格式

此小节主要用于记录一些与加密数据的显示有关的理论知识，不涉及到具体的加密算法的解析。在渗透测试过程中攻击者需要使用各种字符对站点进行测试，通过抓包或通过浏览器查看网页元素就会发现，有些网站响应的数据直接就是明文、有些网站响应的数据是一大串随机字符组合，随机字符组合可能就是服务端使用了一些加密算法或编码

攻击者在对站点进行渗透测试时，通常需要对数据进行增删改查提交测试，对于使用了加密算法或编码的站点，它相应的也会对接收的数据进行解码，如果此时攻击者发送的payload没有进行对应的编码，服务端虽然能够对任意数据进行解码，但解码的结果大概率是无法识别的，这就属于无效测试

因此，无论何种情况下尝试何种攻击手法，攻击者首先都应该保持与服务端使用相同的编码或加密方式，即传输一些服务端能够进行解码或解密的payload

> payload

指的是攻击者执行的测试代码

## 一、数据传输字符

无论数据传输格式使用何种类型，其目的都是为了保护数据的真实内容，避免直接将数据暴露在攻击者视野中。对于攻击者而言，数据传输字符类型会影响到漏洞探针，攻击者必须知晓服务端使用的编码或算法，才能对测试的数据使用同样的编码或算法进行漏洞测试

### 1.1 编码型

字符编码指将人类可识别的字符转换为计算机可识别的二进制数据的规则系统，其核心是建立字符与二进制数字（码点）之间的映射关系，最终目标是为了解决数据的存储、传输、显示问题，确保跨系统兼容性

以一个`https://indialms.in/wfp_login.php?r_id=MQ==`URL链接为示例，问号后面的`r_id=MQ==`明显是一个属性赋值，`MQ==`实际上是一个Base64编码后的字符，通过本地工具`CaptfEncoder`或在线解码工具`http://web.chacuo.net/charsetbase64`对其解码后，实际上`MQ==`就是1

然而，即便已知晓转码后的字符值，在对目标站点进行增删改查提交测试，仍不能直接使用`https://indialms.in/wfp_login.php?r_id=1`提交测试，服务端收到提交测试的数据后，首先会对数据进行Base64解码，然而`r_id=1`解码后的数据明显无法被正常识别

![数据传输-编码型](..\image\Part_1\数据传输-编码型.png)

因此，在对目标进行渗透测试时，攻击者发送的测试数据也要考虑编码、解码问题

### 1.2 加密型

以一个站点的登录页面为例，从这个抓包报文中可以明显得到`username`和`password`两个字段属性，用户名未经加密意味着攻击者在尝试账号破解时可以不必对用户名做出变更，密码字段明显时经过算法得出的字符串，在这种情况下攻击者在尝试账号破解时就必须先对密码数据进行同种算法的计算后，在进行数据的修改测试

![数据传输-加密型](..\image\Part_1\数据传输-加密型.png)

## 二、数据传输格式

常见的数据传输格式分三种：常规格式、JSON格式、XML格式，攻击者通过抓包可以确认客户端与服务端之间使用何种传输格式，在对数据进行增删改查测试时必须要遵守其原本的传输格式

- 常规格式

  `btnPost=%E7%99%BB%E5%BD%95&username=admin&password=21232f297a57a5a743894a0e4a801fc3&savedate=1`

- JSON格式

  ```json
  {
      "btnPost"="%E7%99%BB%E5%BD%95",
      "username"="admin",
      "password"="21232f297a57a5a743894a0e4a801fc3",
      "savedate"="1"
  }
  ```

- XML格式

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <data>
      <btnPost>登录</btnPost>
      <username>admin</username>
      <password>21232f297a57a5a743894a0e4a801fc3</password>
      <savedate>1</savedate>
  </data>
  ```

对于攻击者而言，数据传输格式会产生两方面的影响，对于发送方会影响到漏洞探针，对于回显方会影响到回显数据分析，知晓数据传输使用的格式更有利于攻击者对代码字段所代表的含义进行分析

## 三、密码存储

一般情况下，常规网站的数据库中保存的都是经过加密算法加密后的密文，加密算法多种多样，每种加密算法计算出的密文的表现形式会有一些差异，操作系统、数据库也具备各自的加密算法，经验老道的渗透工程师可以根据密文的表现形式上对加密算法做出大胆推测，但最稳妥的方式仍是拿到后台程序源码，进行代码审计拿到加密算法

然而随着技术的更新迭代，源码本身也会被加密，如何对源码的加密方式进行判断、解密，又成了攻击者拿到源代码后的首要问题。密码存储的方式会影响到后渗透测试，即便攻击者拿到了用户的账号密码信息，但由于无法破译加密算法，仍无法登录系统或网站后台

![密码存储](..\image\Part_1\密码存储.png)

### 3.1 单向散列算法

常见的单向散列算法有：MD5、SHA、MAC、CRC等，单项散列算法的优势在于其密文便于存储，且通过算法进行加密、解密的过程对于设备性能的损耗低，以MD5为例

MD5是一种广泛使用的密码散列函数（哈希算法），属于单向散列算法。MD5用于为数据生成不可逆的128位固定长度的哈希值，通常表示为32位十六进制字符串，MD5计算过程不需要密钥，输入相同数据必然输出相同哈希值。MD5算法曾被广泛应用在文件完整性校验、密码存储等场景，但由于其安全性缺陷，已经不在适用于安全敏感场景，在一般站点仍存在MD5的密码应用

对于MD5算法的破解主要来源：碰撞攻击、彩虹表攻击，碰撞攻击指的是不断使用不同的明文组合进行MD5算法计算，得出MD5值与目标MD5值进行碰撞，直到推算出正确的明文密码；彩虹表攻击指的是将常见的“明文-MD5值”存表，在需要破解密码时快速进行匹配。无论使用哪种方式，破解MD5值仍需要花费大量时间进行计算，只要维持较高的密码复杂度，还是很难通过碰撞攻击、彩虹表攻击及进行密码破解

在大多数业务场景下，还会通过MD5的迭代计算、加盐（Salt）等方式来强化密码的安全性来体育暴力破解。例如`md5(md5(123456).salt)`，所谓Salt简单一点理解可以将其视作一个随机数，以上述函数加密方式为例，假设内部的`md5(123456)`经过一次计算之后的值是`456789`，那么所谓加Salt实际上就是基于首个MD5值追加一些随机数，例如`456789012`，在对这个值进行第二次MD5计算

```php
$salt = substr(uniqid(rand()), -6);       # 生成一个随机字符
$password = md5(md5($password).$salt);    # 对密码进行迭代计算、加盐
/*
假设password值为123456、salt值为012，那么整个计算过程则如下：
md5(md5(123456).012) -> md5(456789.012) -> md5(456789012)
*/
```

### 3.2 加密算法

加密算法使得密码的安全性更上一台阶，即便攻击者获取到数据库权限、拿到用户账户信息，也无法仅凭经过未知算法计算后的一串加密字符串来登录站点。与哈希算法不同，加密算法可以进行逆向解密，但解密需要具备多个前置条件，或者说需要具备多个前置信息才能解密

#### 3.2.1 对称加密算法

加密、解密使用相同的密钥；特点是加密速度快、密文紧凑（明文文件与加密后密文文件大小相差不多）、大型环境下密钥管理复杂（例如电商，一个用户就需要一套密钥）、用于大量数据的传输；生活中汽车钥匙、房屋钥匙都需要使用相同的钥匙打开，即对称加密方式

AES、DES是对称加密算法中最常见的算法，DES全称Data Encryption Standard，在密码技术里需要对encrypt这个单词敏感，它代表加密，与之相对应的decrypt代表解密，3DES又称为TripleDES；现在在对称密钥里用的比较多的技术是AES（Advanced Encryption Standard，高级加密标准），AES是一种区块加密标准，用于代替早期的DES。使用对称加密算法进行加密或解密时都需要具备至少4个辅助元素，以CaptfEncoder工具的使用为例

![加密算法](..\image\Part_1\加密算法.png) 

- Key（密钥）：加密和解密的核心机密，对称加密算法中，加密和解密必须使用相同的Key，Key的生成必须通过密码学安全随机数生成器生成，避免弱密钥
- IV（初始化向量）：用于在不同的Cipher Mode中引入随机性，确保相同的明文在不同的加密算法下生成不同的密文
- Cipher Mode（加密模式）：常见的加密模式有ECB、CBC、CTR等，不同的加密模式，对应的安全性和应用场景不同。例如，ECB模式无需IV即可使用相同的明文可以得到相同的密文、CBC模式需要随机IV进行加密
- Padding Mode（填充模式）：常见的填充模式有PKCS#5、ZeroPadding、NoPadding，填充模式的作用是当明文长度不足时，补充数据至对齐分组大小，确保加密正常进行

使用对称加密算法对数据进行加密或解密时，至少需要具备上述4个信息，其中Cipher Mode、Padding Mode两个参数的可选模式是有限的，可以通过爆破的方式拿到正确信息。但Key、IV（也叫偏移量）两个参数一般是写入源码而非数据库，数据写入时一般先通过源码进行加密后在写入数据库

因此，在渗透测试需要对数据进行解密时，首先需要确认是否能拿到4种辅助信息，本质上也就是确认是否能够拿到后端源码，如果拿不到4种辅助信息或源码，基本上就意味着可以放弃解密

#### 3.2.2 非对称加密算法

加密、解密使用不同的密钥（公钥、私钥）；相比较对称加密算法，非对称加密算法的安全性更好、密钥管理简单，但加密速度慢、耗时长、密文不紧凑（1G数据加密后的密文可能有3G或更大），只适合对少量数据进行加密。因此，非对称加密一般不用于加密实际数据，而用于密钥管理和数字签名

非对称加密的使用方式专注8个字：*公加私解、私加公解*，公钥与私钥可以进行相互交替加解密。非对称加密会产生一副密钥对，私钥个人保存、公钥随意分发：

- 公加私解：表示用公钥对明文进行加密，只能用对应的私钥进行解密，电商就是典型的公加私解的应用。例如，通过个人浏览器访问京东，就能拿到京东的公钥，在浏览器上查看京东站点的证书信息就能够查看到京东的公钥，通过京东的公钥将个人信息加密后发送到京东
- 私加公解：主要用于数字签名，公加私解很好理解，通过公钥加密的客户端数据只能通过服务端私钥解密，正常情况下*私钥只会个人拥有*，那么反向思考，通过私钥加密的数据可以通过公钥解密，如果公钥能够成功解密，说明该数据肯定来自于服务端

常见的非对称加密算法有：RSA、RSA2、PKCS等，一般情况下对称加密算法会和非对称加密算法结合使用，对称加密算法对明文数据进行加密，它的密钥会被当做数据本身，然后通过非对称加密算法对其密钥加密后进行传递

不论是对称加密或非对称加密都涉及到*密钥长度*，密钥长度越长加密数据越安全，但不同算法之间的密钥长度不可以互相比较，不同的算法其本身的安全性可能就已经天差地别，不可单纯靠密钥长度进行对比


### 3.3 算法的推测判断

| 算法&编码 | 特征                                                         |
| --------- | ------------------------------------------------------------ |
| MD5       | 1、由数字“0-9”和小写字母“a-z”组成的字符串<br />2、固定的16位或32位字符串长度<br />3、解密时需提供密文，通过碰撞攻击、彩虹表攻击进行解密，复杂明文难以解密 |
| Base64    | 1、包含大小写字母“A-z”、数字“0-9”以及两个符号“/”、“+”，除了密文尾部易出现“=”号，一般的明文编码后在密文中间很少出现符号，除非明文本身就包含有特殊符号，例如"\>"号<br />2、明文长度越长，密文长度越长 |
| AES、DES  | 1、密文通常以Base64编码呈现，但符号出现在密文中的频率明显更高<br />2、解密时需同时提供密文、Key、VI、Cipher Mode、Padding Mode，条件满足才可解密 |
| RSA       | 1、最常见的编码形式以Base64编码呈现，也存在一些其他的编码格式，总体特征仍与AES、DES密文特征相似，但长度更长<br />2、解密时需要对应的公钥或私钥 |

实际上被用于密码存储算法远不止这几种，除了上述列出的密文特征，各种编程语言本身还自带了加密函数，通过编程语言自带的加密函数输出的密文特征，又与原始的加密算法计算出的密文特征不一样。因此，在破解密码的过程中，优先获取后端源码，通过代码审计获取数据加密算法，再进行解密，在拿不到后端源码的情况下，根据经验判断密文类型属于哪种加密算法，尝试解密，但能否成功解密仍无法确认

## 四、字符集与编码方案

提到字符编码可能会联想到GBK、UTF-8，为了避免混淆GBK、UTF-8、Base64之间的概念与作用，此处对字符编码进行一个简单的概述。在了解字符编码之前首先需要对三个名词有一个基本概念：

- 字符集（Character Set）：用于为人类可识别的每个字符分配一个唯一编号，该编号又称为码点（Code Point）
- 编码规则（Encoding Rule）：建立字符与码点之间的映射关系，码点本质上就是二进制数据
- 编码方案：一套完整的编码体系，包含字符集定义、编码规则、错误处理等机制

字符编码本身是一个广义规则，它包含字符集和编码规则两层含义，被用于在人类和机器之间做语言转换，常见的字符编码包括ASCII、GBK、UTF-8等。以ASCII为例，将其称为字符编码就意味着，ASCII本身其实就已经包含字符集和编码规则，只不过口语或表达上，可能也会将其称为ASCII字符集

ASCII、GBK、UTF-8都是字符编码，它们都属于同一个层级，只不过各自的应用场景与适用场景不同。以ASCII为例，它是早期计算机系统的字符编码的基础标准之一，但由于只定义了128个字符的码点，因此只适用于全英文和少量特殊符号的场景，一般应用在基本本文存储与传输

Base64是一种二进制转文本的编码方案，其核心功能是将任意二进制数据（如图片、加密数据）转换为由64个可打印ASCII字符组成的文本格式。Base64不是字符集，也与字符编码无关，但它依赖ASCII字符编码作为载体，本身不定义新字符，而是利用现有字符实现数据格式转换

在层级关系上，Base64与字符编码亦有差异，字符编码属于基础层，解决字符转二进制的映射问题。Base64属于转换层，以ASCII作为“运输箱”解决二进制数据在文本环境中的传输问题，与字符编码本质不同。Base64的工作流程是：`原始文本（如中文“你好”）→ UTF-8编码为二进制 → Base64转为ASCII文本（如"5L2g5aW9"）→ 传输 → Base64解码回二进制 → UTF-8解码还原文本`

到此为止，其实概念上来看，字符编码和Base64似乎都是为了解决人类与计算机之间的“语言沟通”问题，那么为什么还需要Base64编码方案呢？因为文本协议对二进制的“排斥”，即便强如UTF-8能编码全球字符，在诸如电子邮件传输、老旧系统的兼容性、URL和文件名的安全性场景中直接传输二进制数据仍会出现问题

比如，二进制数据中可能包含空格、?、#等字符，这些字符对于URL而言都是非法字符，而Base64生成的字符对于URL而言均为合法字符。然而Base64仍具备其局限性，典型的三个问题包括：数据膨胀33%、非加密数据、性能损耗

将字符按照码点转换为二进制的过程，称之为编码（Encode），反之为解码（Decode）。字符编码是数字世界的语言翻译官，当两个对象互相通信所使用的编码格式不同时，最明显的问题就是会出现乱码
