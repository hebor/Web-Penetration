# 容器

容器同样属于虚拟化技术，相比较虚拟机，容器更加轻量化

## 一、理论知识

网安笔记跳过Docker的理论知识，请跳转到[运维笔记](https://github.com/hebor/docker)查看Docker运行原理

## 二、安装Docker

1. 基本环境准备

   ```bash
   systemctl stop firewalld    # 关闭防火墙
   setenforce 0    # 关闭SELinux
   ntpdate cn.pool.ntp.org    # 服务器时间同步
   ```

2. 安装Docker

   ```bash
   yum install -y yum-utils    # 准备YUM工具集合
   yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo    # 安装阿里云的docker-ce的YUM源
   yum install -y docker-ce    # 安装Docker软件包
   ```

3. 修改Linux内核参数

   ```bash
   modprobe br_netfilter    # 加载Linux内核模块
   cat > /etc/sysctl.d/docker.conf <<EOF    # 修改Linux内核参数
   net.bridge.bridge-nf-call-ip6tables = 1
   net.bridge.bridge-nf-call-iptables = 1
   net.ipv4.ip_forward = 1
   EOF
   sysctl -p /etc/sysctl.d/docker.conf    # 使内核参数立即生效
   lsmod | grep "br_netfilter"            # 校验内核模块是否正常加载
   ```

4. 启用服务

   ```bash
   systemct enable --now docker
   systemctl status docker
   ```

## 三、Docker管理

Docker的命令格式已经经过变更，早期的命令格式更加简洁，但各个实现的功能比较混乱，Docker在保留早期命令格式的前提下对命令选项做了功能打包整理。例如，早期查看本地镜像使用`docker images`，变更后的命令将有关镜像的操作划分到了image选项下，现在可以通过`docker image ls`查看镜像，命令格式更加规范

### 3.1 image

```bash
# 1.从Registry拉取镜像
docker image pull centos

# 2.将本地镜像制作为离线压缩包
docker image save -o centos.tar.gz centos

# 3.删除本地镜像，删除本地镜像前需要确保没有容器正在使用此镜像
docker image rm centos

# 4.加载离线压缩包
docker image load -i centos.tar.gz
```

### 3.2 Container

```bash
# 1.查看容器
docker container ls
	-a：查看所有容器，包括未启动的容器
	
# 2.运行一个新容器
docker container run --name centos01 -it centos:latest    # 运行一个容器并进入容器中进行交互操作
    --name：为容器指定一个名称
    -i,--interactive：保持容器标准输入（STDIN）打开，用于允许用户或外部程序与容器进行交互
    -t,--tty：分配一个伪TTY
    -d,--detach：在后台运行容器并打印容器ID
docker container run --name centos02 -td centos:latest    # 将容器运行在后台

# 3.进入后台容器
docker container exec -it centos02 /bin/bash

# 4.停止容器
docker container stop centos02

# 5.删除容器
docker container rm centos02
    -f：强制删除容器，包括运行状态的容器

# 6.启用容器
docker container start centos01

# 7.重启容器
docker container restart centos01

# 8.获取容器运行日志
docker container logs centos01
```

### 3.3 Volume

缺省情况下容器使用临时Volume用于存储数据，容器被删除时，临时Volume会保留，这可能会导致Docker服务端的磁盘可用量越来越少，缺省的临时Volume路径是``。持久性Volume可以使容器的数据脱离容器的生命周期管理，容器的删除不会直接影响到数据的安全性，甚至通过共享的持久性存储还能够实现容器的无缝迁移

```bash
mkdir -p /data/docker/centos02    # Docker在使用Volume前需要在主机上创建挂载点
docker container run --name centos02 -v /data/docker/centos02:/data -id centos    # 运行容器
    -v：指定持久化存储目录

# 在容器内创建测试文件
docker container exec -it centos02 /bin/bash
echo "hebor test" > /data/container.txt
exit

# 检测宿主机挂载点是否存在数据
cat /data/docker/centos02/container.txt

# 删除容器并检测宿主机数据是否正常
docker container rm -f centos02
cat /data/docker/centos02/container.txt

# 新建一个容器并使用同一个挂载点
docker container run --name centos03 -v /data/docker/centos02:/data/ -id centos
docker container exec -it centos03 /bin/bash
cat /data/container.txt    # 在容器内检测旧数据是否正常
exit

# 新建容器并设置Volume为只读
docker container run --name centos04 -v /data/docker/centos02/:/data/:ro -id centos
docker container exec -it centos04 /bin/bash
cat /data/container.txt
echo "centos04 test" > /data/container04.txt    # 写入权限拒绝
exit
```

在容器中使用持久性Volume时，宿主机的挂载点内产生的新数据会被同步到容器的持久化目录中，可以在运行容器时可以设置持久化存储为只读权限，这样容器就无法在持久化目录下写入新数据

### 3.4 dockerfile

dockerfile类似脚本文件，docker会按照dockerfile的编写内容逐步执行命令，需要注意的是文件命名本身就必须是dockerfile，文件名称有差异时Docker无法正常识别

```bash
vim dockerfile
FROM centos
RUN sed -i "s|mirrorlist=|#mirrorlist=|g" /etc/yum.repos.d/CentOS-*
RUN sed -i "s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g" /etc/yum.repos.d/CentOS-*
RUN yum install -y wget
RUN yum install -y nginx
EXPOSE 80
CMD /bin/bash

# 使用当前目录下的dockerfile构建镜像
docker build -t 'web' .
docker image ls
```

### 3.5 Network

在安装Docker时会自动生成一个docker0的虚拟网桥，每运行一个容器都会生成一个veth设备对，veth设备对就像是一条网线存在两头，一头接在容器里、另一头接在docker0网桥上，通过`brctl show`可以更直观的进行管理

Docker默认具备4种网络模型：

| 模型      | 说明                                              |
| --------- | ------------------------------------------------- |
| bridge    | 默认使用的网络模型，NAT网络，与物理机进行网络通讯 |
| host      | 共享物理主机的网络地址信息                        |
| none      | 启用的容器默认没有IP配置，可以手动设置IP信息      |
| container | 启动容器与已有容器共享网络                        |

```bash
# host模型，完全共享宿主机的网络信息
docker container run --name centos04 --network host -it centos

# none模型，默认没有IP配置
docker container run --name centos05 --network=none -it centos

# container模型，与一个正在运行的容器共享同一个network namespace，简单一点理解就是两个容器共用同一套网络信息
docker container run --name centos06 --network=container:centos04 -it centos
```

#### 3.5.1 容器间的网络通信

缺省情况下，Docker创建容器会使用bridge模型，所有的容器天然就在一个局域网内，一般情况下容器之间可以直接互联，但由于容器本身的特性，部分容器的生命周期可能非常短，一旦容器重启就有可能导致容器的IP产生变化。容器的网络别名可以避免因容器重启而导致的IP变化问题

```bash
# 运行一个web03容器
docker container run --name web03 -id web

# 运行一个web04容器，并在web04容器中声明web03容器的网络别名为webtest
docker container run --name web04 -id --link=web03:webtest web
    --link：为容器设置网络别名
docker container exec -it web04 /bin/bash
ping webtest    # 以别名进行通信
```

#### 3.5.2 端口映射

web镜像中虽然已经安装有nginx程序，但容器明显还无法对外提供服务，容器之间的互联本质上还是同一台宿主机的内部通信，如果要把容器内的服务对外开放，则需要借助端口映射来实现

```bash
docker container run --name web05 -p 8080:80 -id web
    -p：将容器的80端口映射到物理机的8080端口
docker container exec -it web05 /bin/bash
nginx    # 启用nginx服务
exit

iptables -t nat -nvL
...
Chain DOCKER (2 references)
 pkts bytes target     prot opt in     out     source               destination         
    0     0 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0           
   48  2504 DNAT       tcp  --  !docker0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:8080 to:172.17.0.2:80
```

> **如何判断渗透进入的环境是虚拟机还是容器？**

1. 通过`/proc/1/cgroup`文件判断

   ```bash
   # 虚拟机的控制组全都挂在 /根目录 上
   cat /proc/1/cgroup 
   11:freezer:/
   10:blkio:/
   ...
   
   # Docker容器的控制组都挂在 /docker/目录 上
   cat /proc/1/cgroup
   11:freezer:/docker/0ded315af46fc18d283d77eebcc9237d147bc792e5d3004d343f596781cd7929
   10:blkio:/docker/0ded315af46fc18d283d77eebcc9237d147bc792e5d3004d343f596781cd7929
   ```

   如果容器使用是Kubernetes环境，则`/proc/1/cgroup`文件中会显示控制组都挂在 `/kubepods`目录上

2. 通过根目录的隐藏文件判断

   ```bash
   # Docker容器的根目录
   ls -la /
   -rwxr-xr-x.   1 root root   0 Jul 10 15:32 .dockerenv
   ```

   Docker容器的根目录会存在`.dockerenv`隐藏文件

### 其他

```bash
# 从Registry搜索镜像
docker search centos
```



**jumpserver的4A能力**

身份鉴别、账号管理、权限控制、安全审计
